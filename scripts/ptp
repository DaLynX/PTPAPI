#!/bin/env python
import logging
import os.path
from urlparse import urlparse, parse_qs

import argparse
import tempita

import ptpapi

logger = logging.getLogger(__name__)


def ellipsize(string, length):
    if len(string) > length:
        return string[:length-3] + '...'
    return string


def do_inbox(api, args):
    if args.conversation:
        conv = api.current_user().inbox_conv(args.conversation)
        print conv['Subject']
        for m in conv['Message']:
            print "{0} - {1}\n".format(m['User'], m['Time'])
            print m['Text']
            print '----------------------------'
        return
    msgs = list(api.current_user().inbox())
    print "ID" + ' '*6 + "Subject" + ' '*25 + 'Sender' + ' '*9
    print '-'*55
    for m in msgs:
        if args.unread and m['Unread'] is False:
            continue
        if args.user is not None and m['Sender'] != args.user:
            continue
        print "{0: <8}{1: <32}{2: <15}".format(
            m['ID'],
            ellipsize(m['Subject'], 30),
            ellipsize(m['Sender'], 15))


def do_download(api, args):
    for arg in args.turl:
        url_args = parse_qs(urlparse(arg).query)
        if 'torrentid' in url_args:
            t = ptpapi.Torrent(url_args['torrentid'][0])
        elif 'action' in url_args and url_args['action'][0] == 'download':
            t = ptpapi.Torrent(url_args['id'][0])
        else:
            logger.warning('URL {0} doesn\'t appear to be a PTP torrent link.'.format(arg))
            continue
        t.download_to_file()

def parse_terms(termlist):
    torrents = []
    movies = []
    terms = {}
    target = 'torrents'

    for arg in termlist:
        url = urlparse(arg)
        url_args = parse_qs(url.query)
        if url.path == '/collages.php':
            target = 'collage'
            terms['id'] = url_args['id'][0]
        elif 'torrentid' in url_args:
            torrents.append(ptpapi.Torrent(url_args['torrentid'][0]))
        elif 'id' in url_args:
            if 'action' in url_args and url_args['action'][0] == 'download':
                torrents.append(ptpapi.Torrent(url_args['id'][0]))
            else:
                movies.append(ptpapi.Movie(url_args['id'][0]))
        else:
            term = arg.partition('=')
            if not term[2]:
                if term[0] == 'bookmarks':
                    target = 'bookmarks'
                else:
                    terms['searchstr'] = term[0]
            else:
                term_map = {
                    'taglist': [ 'genre', 'genres', 'tags' ],
                    'name': [ 'searchstr' ]
                }
                for k, v in term_map.items():
                    if term[0] in v:
                        term = (k, term[1], term[2])
                terms[term[0]] = term[2]
    return (target, movies, torrents, terms)


def do_search(api, args):
    (target, movies, torrents, terms) = parse_terms(args.search_terms)
    if args.movie_format is not None:
        movie_template = tempita.Template(args.movie_format)
    else:
        movie_template = tempita.Template("{{Title}} ({{Year}}) - {{','.join([d['Name'] for d in Directors])}} - [{{'/'.join(Tags)}}] - [PTP {{GroupId}}, IMDB tt{{ImdbId}}]")
    if args.torrent_format is not None:
        torrent_template = tempita.Template(args.torrent_format)
    else:
        torrent_template = tempita.Template("- {{Codec}}/{{Container}}/{{Source}}/{{Resolution}} - {{ReleaseName}} - {{Snatched}}/{{Seeders}}/{{Leechers}}")

    # If we haven't found any URL-looking things
    if not movies and not torrents:
        if target == 'torrents':
            logger.debug("Searching all torrents with {0}".format(terms))
            movies = api.search(terms)
        elif target == 'bookmarks':
            logger.debug("Searching bookmarks with {0}".format(terms))
            movies = api.current_user().bookmarks(search_terms=terms)
        elif target == 'collage':
            logger.debug("Searching collage {0} with {1}".format(terms['id'], terms))
            movies = api.collage(terms['id'], terms)
        if args.limit:
            movies = movies[:args.limit]

    if args.download:
        for m in movies:
            match = m.best_match(args.filter)
            if match and not args.dry_run:
                match.download_to_file()
            elif args.dry_run:
                logger.info("Dry-run, not downloading %s" % match)
            else:
                logger.info("No match found for for movie %s (%s)" % (m['Title'], m['Year']))
        for t in torrents:
            if args.download and not args.dry_run:
                t.download_to_file()
            elif args.dry_run:
                logger.info("Dry-run, not downloading %s" % t)
    else:
        for m in movies:
            print movie_template.substitute(m)
            for t in m['Torrents']:
                print torrent_template.substitute(t)
        for t in torrents:
            print torrent_template.substitute(t)


def do_raw(api, args):
    for u in args.url:
        url = urlparse(u)
        data = ptpapi.session.session.base_get('?'.join([url.path, url.query])).content
        with open(os.path.basename(url.path), 'w') as fh:
            fh.write(data)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Extensible command line utility for PTP')
    parser.add_argument('--debug', help='Print lots of debugging statements',
                        action="store_const", dest="loglevel", const=logging.DEBUG, default=logging.WARNING)
    parser.add_argument('-v', '--verbose', help='Be verbose', action="store_const", dest="loglevel", const=logging.INFO)
    subparsers = parser.add_subparsers()

    search_parser = subparsers.add_parser('search')
    search_parser.add_argument('search_terms', help="""A list of terms in [field]=[text] format.
                               If the '=' is omitted, the field is assumed to be 'name'.""", nargs='+', metavar='term')
    search_parser.add_argument('-d', '--download', help="Download any movies found", action="store_true")
    search_parser.add_argument('-n', '--dry-run', help="Don't actually download any torrents", action='store_true')
    search_parser.add_argument('-l', '--limit', help="Limit search results to N movies", default=None, type=int)
    search_parser.add_argument('-f', '--filter', help="Define a filter to download movies with",
                               default=ptpapi.config.config.get('Main', 'filter'))
    search_parser.add_argument('--movie-format', help="Set the output for movies", default=None)
    search_parser.add_argument('--torrent-format', help="Set the output for torrents", default=None)
    search_parser.set_defaults(func=do_search)

    download_parser = subparsers.add_parser('download')
    download_parser.add_argument('turl', help="A list of torrent URLs to download from", nargs='+', metavar='torrent URL')
    download_parser.set_defaults(func=do_download)

    inbox_parser = subparsers.add_parser('inbox')
    inbox_parser.add_argument('-u', '--unread', help="Only show unread messages", action="store_true")
    inbox_parser.add_argument('--user', help="Filter messages by the sender")
    inbox_parser.add_argument('-c', '--conversation', help="Get the messages of a specific conversation", type=int)
    inbox_parser.set_defaults(func=do_inbox)

    raw_parser = subparsers.add_parser('raw')
    raw_parser.add_argument('url', help="A list of urls to download", nargs='+')
    raw_parser.set_defaults(func=do_raw)

    args = parser.parse_args()

    logging.basicConfig(level=args.loglevel)

    api = ptpapi.login()

    args.func(api, args)
