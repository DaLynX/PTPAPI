#!/bin/env python
import logging
import os.path
from urlparse import urlparse, parse_qs
from time import sleep

import argparse
import tempita

import ptpapi

logger = logging.getLogger(__name__)


def ellipsize(string, length):
    if len(string) > length:
        return string[:length-3] + '...'
    return string


def do_inbox(api, args):
    if args.conversation:
        conv = api.current_user().inbox_conv(args.conversation)
        print conv['Subject']
        for m in conv['Message']:
            print "{0} - {1}\n".format(m['User'], m['Time'])
            print m['Text']
            print '----------------------------'
        return
    if args.mark_read:
        for conv in args.mark_read:
            api.current_user().inbox_conv(conv)
        return
    msgs = list(api.current_user().inbox())
    print "ID" + ' '*6 + "Subject" + ' '*25 + 'Sender' + ' '*9
    print '-'*55
    for m in msgs:
        if args.unread and m['Unread'] is False:
            continue
        if args.user is not None and m['Sender'] != args.user:
            continue
        print "{0: <8}{1: <32}{2: <15}".format(
            m['ID'],
            ellipsize(m['Subject'], 30),
            ellipsize(m['Sender'], 15))


def parse_terms(termlist):
    torrents = []
    movies = []
    terms = {}
    target = 'torrents'

    for arg in termlist:
        url = urlparse(arg)
        url_args = parse_qs(url.query)
        if url.path == '/collages.php':
            target = 'collage'
            terms['id'] = url_args['id'][0]
        elif 'torrentid' in url_args:
            torrents.append(ptpapi.Torrent(url_args['torrentid'][0]))
        elif 'id' in url_args:
            if 'action' in url_args and url_args['action'][0] == 'download':
                torrents.append(ptpapi.Torrent(url_args['id'][0]))
            else:
                movies.append(ptpapi.Movie(url_args['id'][0]))
        else:
            term = arg.partition('=')
            if not term[2]:
                if term[0] == 'bookmarks':
                    target = 'bookmarks'
                else:
                    terms['searchstr'] = term[0]
            else:
                term_map = {
                    'taglist': ['genre', 'genres', 'tags'],
                    'name': ['searchstr']
                }
                for k, v in term_map.items():
                    if term[0] in v:
                        term = (k, term[1], term[2])
                terms[term[0]] = term[2]
    return (target, movies, torrents, terms)


def do_search(api, args):
    (target, movies, torrents, terms) = parse_terms(args.search_terms)
    if args.movie_format is not None:
        movie_template = tempita.Template(args.movie_format)
    else:
        movie_template = tempita.Template("{{Title}} ({{Year}}) - {{','.join([d['Name'] for d in Directors])}} - "
                                          "[{{'/'.join(Tags)}}] - [PTP {{GroupId}}, IMDB tt{{ImdbId}}]")
    if args.torrent_format is not None:
        torrent_template = tempita.Template(args.torrent_format)
    else:
        torrent_template = tempita.Template("- {{Codec}}/{{Container}}/{{Source}}/{{Resolution}} - {{ReleaseName}} - "
                                            "{{Snatched}}/{{Seeders}}/{{Leechers}}")

    # If we haven't found any URL-looking things
    if not movies and not torrents:
        logger.debug('Attempting to search target "%s" with terms %s' % (target, terms))
        if target == 'torrents':
            movies = api.search(terms)
        elif target == 'bookmarks':
            movies = api.current_user().bookmarks(search_terms=terms)
        elif target == 'collage':
            movies = api.collage(terms['id'], terms)
        movies = movies[:args.limit]

    if args.download:
        for m in movies[:args.limit]:
            match = m.best_match(args.filter)
            if match and not args.dry_run:
                match.download_to_file()
            elif args.dry_run:
                logger.info("Dry-run, not downloading %s" % match)
            else:
                logger.info("No match found for for movie %s (%s)" % (m['Title'], m['Year']))
        for t in torrents:
            if args.download and not args.dry_run:
                t.download_to_file()
            elif args.dry_run:
                logger.info("Dry-run, not downloading %s" % t)
    else:
        for m in movies[:args.limit]:
            print movie_template.substitute(m)
            for t in m['Torrents']:
                print torrent_template.substitute(t)
        for t in torrents:
            print torrent_template.substitute(t)


def do_raw(api, args):
    for u in args.url:
        url = urlparse(u)
        data = ptpapi.session.session.base_get('?'.join([url.path, url.query])).content
        with open(os.path.basename(url.path), 'w') as fh:
            fh.write(data)


def do_log(api, args):
    interval = 30.0
    lastmsg = None
    while (True):
        printmsg = False
        msgs = api.log()
        # We actually want it 'reversed' by default
        if not args.reverse:
            msgs.reverse()
        for time, msg in msgs:
            if lastmsg is None or printmsg:
                print time, '-', msg
                lastmsg = msg
            if lastmsg == msg:
                printmsg = True
        if args.follow:
            sleep(interval)
        else:
            break


def add_verbosity_args(p):
    p.add_argument('--debug', help='Print lots of debugging statements',
                   action="store_const", dest="loglevel", const=logging.DEBUG, default=logging.WARNING)
    p.add_argument('-v', '--verbose', help='Be verbose', action="store_const", dest="loglevel", const=logging.INFO)
    p.add_argument('-q', '--quiet', help='Hide most messages', action="store_const", dest="loglevel", const=logging.CRITICAL)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Extensible command line utility for PTP')
    add_verbosity_args(parser)
    subparsers = parser.add_subparsers()

    search_parent = argparse.ArgumentParser()
    add_verbosity_args(search_parent)
    search_parent.add_argument('search_terms', help="""A list of terms in [field]=[text] format.
                               If the '=' is omitted, the field is assumed to be 'name'.""", nargs='+', metavar='term')
    search_parent.add_argument('-n', '--dry-run', help="Don't actually download any torrents", action='store_true')
    search_parent.add_argument('-l', '--limit', help="Limit search results to N movies", default=100, type=int)
    search_parent.add_argument('-f', '--filter', help="Define a filter to download movies with",
                               default=ptpapi.config.config.get('Main', 'filter'))
    search_parent.add_argument('--movie-format', help="Set the output for movies", default=None)
    search_parent.add_argument('--torrent-format', help="Set the output for torrents", default=None)

    search_parser = subparsers.add_parser('search', help='Search for or download movies', add_help=False, parents=[search_parent])
    search_parser.add_argument('-d', '--download', help="Download any movies found", action="store_true")
    search_parser.set_defaults(func=do_search)

    download_parser = subparsers.add_parser('download', help='An alias for search -d', add_help=False, parents=[search_parent])
    download_parser.add_argument('-d', '--download', help="Download any movies found", action="store_true", default=True)
    download_parser.set_defaults(func=do_search)

    inbox_parser = subparsers.add_parser('inbox', help='Reads messages in your inbox')
    add_verbosity_args(inbox_parser)
    inbox_parser.add_argument('-u', '--unread', help="Only show unread messages", action="store_true")
    inbox_parser.add_argument('-m', '--mark-read', help="Mark messages as read", type=lambda s: [int(n) for n in s.split(',')])
    inbox_parser.add_argument('--user', help="Filter messages by the sender")
    inbox_parser.add_argument('-c', '--conversation', help="Get the messages of a specific conversation", type=int)
    inbox_parser.set_defaults(func=do_inbox)

    raw_parser = subparsers.add_parser('raw', help='Fetch the raw HTML of pages')
    add_verbosity_args(raw_parser)
    raw_parser.add_argument('url', help="A list of urls to download", nargs='+')
    raw_parser.set_defaults(func=do_raw)

    log_parser = subparsers.add_parser('log', help='Show the log of recent events')
    add_verbosity_args(log_parser)
    log_parser.add_argument('-r', '--reverse', help='Sort in reverse', action='store_true')
    log_parser.add_argument('-f', '--follow', help='Print new entries as they appear', action="store_true")
    log_parser.set_defaults(func=do_log)

    args = parser.parse_args()

    logging.basicConfig(level=args.loglevel)

    api = ptpapi.login()

    args.func(api, args)
