#!/usr/bin/env python
import sys
import os
import os.path
import xmlrpclib
import argparse
import logging
from time import sleep
from urlparse import urlparse, parse_qs
from collections import namedtuple

from pyrobase import bencode
from pyrocore import config
from pyrocore.util import load_config, metafile

import ptpapi

logger = logging.getLogger(__name__)


# A tiny class to make code cleaner,
# as well as possibly making adding something like a confidence indicator easier
# ID is an integer-as-a-string, and path is filepath
class Match(namedtuple('Match', 'ID path')):
    def __nonzero__(self):
        if self.ID is not None and self.path is not None:
            return True
        return False


def match_by_torrent(torrent, filepath, dry_run=False, action='hard'):
    logger.debug(u"Attempting to match against torrent {0} ({1})".format(torrent.ID, torrent.ReleaseName))

    path1 = os.path.abspath(filepath)
    path1_files = {}
    if os.path.isdir(path1):
        for root, directories, filenames in os.walk(path1):
            for filename in filenames:
                f = os.path.join(root, filename).replace(os.path.dirname(path1) + os.sep, '')
                path1_files[f] = os.path.getsize(os.path.join(root, filename))
    elif os.path.isfile(path1):
        path1_files[path1.replace(os.path.dirname(path1) + os.sep, '')] = os.path.getsize(path1)

    path2_files = dict((os.path.join(torrent.ReleaseName, f), int(s)) for f, s in torrent.Filelist.items())

    if len(path1_files) < len(path2_files):
        logger.debug("Too little files to match torrent ({0} locally, {1} in torrent)".format(len(path1_files), len(path2_files)))
        return Match(None, None)

    matched_files = {}
    logger.debug("Looking for exact matches")
    for filename, size in path1_files.items():
        if filename in path2_files.keys() and path2_files[filename] == size:
            matched_files[filename] = filename
            del path1_files[filename]
            del path2_files[filename]
    logger.debug("{0} of {1} files matched".format(len(matched_files), len(path2_files) + len(matched_files)))

    # If the match is 1:1, no need to go through with the rest of the rigmarole
    if len(path2_files) == 0:
        logger.debug("Found exact file match, returning early")
        return Match(torrent.ID, path1)

    logger.debug("Looking for matches with same size and name but different root folder")
    for filename1, size1 in path1_files.items():
        no_root1 = os.sep.join(os.path.normpath(filename1).split(os.sep)[1:])
        for filename2, size2 in path2_files.items():
            no_root2 = os.sep.join(os.path.normpath(filename2).split(os.sep)[1:])
            if no_root1 == no_root2 and size1 == size2:
                matched_files[filename1] = filename2
                del path1_files[filename1]
                del path2_files[filename2]
                break
    logger.debug("{0} of {1} files matched".format(len(matched_files), len(path2_files) + len(matched_files)))

    logger.debug("Looking for matches with same base name and size")
    for filename1, size1 in path1_files.items():
        for filename2, size2 in path2_files.items():
            if os.path.basename(filename1) == os.path.basename(filename2) and size1 == size2:
                if os.path.basename(filename1) not in [os.path.basename(p) for p in path2_files.keys()]:
                    matched_files[filename1] = filename2
                    del path1_files[filename1]
                    del path2_files[filename2]
                    break
    logger.debug("{0} of {1} files matched".format(len(matched_files), len(path2_files) + len(matched_files)))

    logger.debug("Looking for matches by size only")
    for filename1, size1 in path1_files.items():
        for filename2, size2 in path2_files.items():
            if size1 == size2 and path2_files.values().count(size2) == 1:
                matched_files[filename1] = filename2
                del path1_files[filename1]
                del path2_files[filename2]
                break
    logger.debug("{0} of {1} files matched".format(len(matched_files), len(path2_files) + len(matched_files)))

    if len(path2_files) > 0:
        logger.debug("Not all files could be matched, returning...")
        return Match(None, None)

    # Start creating the matched files

    if dry_run:
        logger.debug("Skipping file creation")
    else:
        for origin_file, matched_file in matched_files.items():
            origin_file = os.path.join(os.path.dirname(path1), origin_file)
            file_to_create = os.path.join(os.path.dirname(path1), matched_file)
            path_to_create = os.path.dirname(file_to_create)
            try:
                logger.debug(u"Creating directory '{0}'".format(path_to_create))
                os.makedirs(path_to_create)
            except OSError as e:
                if e.errno != 17:
                    raise
            if os.path.lexists(file_to_create):
                logger.debug(u"File '{0}' already exists, skipping creation".format(file_to_create))
                continue
            logger.debug(u"Creating file '{0}' from '{1}' via action '{2}'".format(file_to_create, origin_file, action))
            if action == 'soft':
                os.symlink(os.path.relpath(origin_file, os.path.dirname(file_to_create)), file_to_create)
            elif action == 'hard':
                os.link(origin_file, file_to_create)
    return Match(torrent.ID, os.path.join(os.path.dirname(path1), torrent.ReleaseName))


def match_by_movie(movie, filename):
    logger.debug(u"Attempting to match against movie {0} ({1})".format(movie.ID, movie.Title))

    movie.load_html_data()
    for t in movie.Torrents:
        match = match_by_torrent(t, os.path.abspath(filename))
        if match:
            return Match(t.ID, match)
    return Match(None, None)


def match_by_guessed_name(ptp, filepath, name=None):
    filepath = os.path.abspath(filepath)
    try:
        import guessit
    except ImportError:
        logger.debug("Error importing 'guessit' module, skipping name guess")
        return Match(None, None)
    logger.debug("Guessing name from filepath with guessit")
    if not name:
        name = os.path.basename(filepath)
    guess = guessit.guess_movie_info(name)
    if guess['title']:
        movies = ptp.search({'searchstr': guess['title']})
        if len(movies) == 0:
            movies = ptp.search({'searchstr': guess['title'], 'inallakas': '1'})
        if len(movies) == 0:
            logger.debug("Could not find any movies by search with a guessed name")
        for m in movies:
            match = match_by_movie(m, filepath)
            if match:
                return match
    return Match(None, None)


def match_against_file(ptp, filepath):
    filepath = os.path.abspath(filepath)
    if not os.path.exists(filepath):
        logger.error(u"File/directory {0} does not exist".format(filepath))
        return Match(None, None)
    logger.debug("Searching movies by file list")
    for m in ptp.search({'filelist': os.path.basename(filepath)}):
        match = match_by_movie(m, filepath)
        if match:
            return match
    return match_by_guessed_name(ptp, filepath)


def load_torrent(proxy, ID, path):
    torrent = ptpapi.Torrent(ID=ID)
    torrent_data = torrent.download()
    data = bencode.bdecode(torrent_data)
    thash = metafile.info_hash(data)
    try:
        logger.debug(u"Testing for hash {0}".format(proxy.d.hash(thash, fail_silently=True)))
        logger.error(u"Hash {0} already exists in rtorrent as {1}, cannot load.".format(thash, proxy.d.name(thash)))
        return
    except xmlrpclib.Fault:
        pass
    proxy.load_raw(xmlrpclib.Binary(torrent_data))
    # Wait until the torrent is loaded and available
    while True:
        sleep(1)
        try:
            proxy.d.hash(thash, fail_silently=True)
            break
        except xmlrpclib.Fault:
            pass
    logger.info(u"Torrent loaded at {0}".format(path))
    proxy.d.directory_base.set(thash, path)
    proxy.d.check_hash(thash)


def main():
    parser = argparse.ArgumentParser(description='Attempt to find and reseed torrents on PTP')
    parser.add_argument('-u', '--url', help='Permalink to the torrent page')
    parser.add_argument('files', help='Paths directly to files/directories', nargs='+')
    parser.add_argument('-n', '--dry-run', help="Don't actually create any files or load torrents", action="store_true")
    parser.add_argument('-a', '--action', help="Method to use when creating files", choices=['hard', 'soft'])
    parser.add_argument('--loop', help="Run in loop mode to avoid rapid session creation", action="store_true")
    parser.add_argument('--batch', help='Take a list of file names to process (stdin by default)', type=argparse.FileType('r'),
                        nargs='?', const=sys.stdin, default=None)
    parser.add_argument('--debug', help='Print lots of debugging statements',
                        action="store_const", dest="loglevel", const=logging.DEBUG, default=logging.WARNING)
    parser.add_argument('-v', '--verbose', help='Be verbose', action="store_const", dest="loglevel", const=logging.INFO)
    parser.add_argument('-q', '--quiet', help='Don\'t show any messages', action="store_const", dest="loglevel", const=logging.CRITICAL)
    args = parser.parse_args()

    logging.basicConfig(level=args.loglevel)

    # Load pyroscope
    load_config.ConfigLoader().load()
    proxy = config.engine.open()

    # Futile attempt to impose our loglevel upon pyroscope
    logging.basicConfig(level=args.loglevel)

    # Load PTP API
    ptp = ptpapi.login()

    if args.batch:
        logger.debug("Reading in file names from {0}".format(args.batch))
        for line in args.batch:
            match = match_against_file(ptp, line.rstrip('\n').decode('UTF-8'))
            if match:
                if not args.dry_run:
                    load_torrent(proxy, match.ID, match.path)
            else:
                logger.error(u"Could not find match for file {0}".format(line.rstrip('\n').decode('UTF-8')))
        return

    if args.loop:
        print "Entering file read loop. Enter 'q', 'quit' or 'exit' to exit the loop."
        while True:
            filepath = raw_input('file>>> ').decode('UTF-8')
            if filepath in ['q', 'quit', 'exit']:
                break
            match = match_against_file(ptp, filepath)
            if match:
                if not args.dry_run:
                    load_torrent(proxy, match.ID, match.path)
            else:
                logger.error(u"Could not find match for file {0}".format(filepath))
        return

    match = Match(None, None)

    if args.file:
        arg_file = args.file.decode('UTF-8')

    for f in args.files:
        arg_file = f.decode('UTF-8')

        if args.url:
            parsed_url = parse_qs(urlparse(args.url).query)
            if 'torrentid' in parsed_url:
                match = match_by_torrent(ptpapi.Torrent(ID=parsed_url['torrentid'][0]), arg_file)
            elif 'id' in parsed_url:
                match = match_by_movie(ptpapi.Movie(ID=parsed_url['id'][0]), arg_file)
        elif arg_file:
            match = match_against_file(ptp, arg_file)

        # Make sure we have the minimum information required
        if not match:
            logger.error("Could not find an associated torrent, cannot reseed")
            return

        logger.info(u"Found match, now loading torrent {0} to path {1}".format(match.ID, match.path))
        if args.dry_run:
            logger.debug("Stopping before actual load")
            return
        load_torrent(proxy, match.ID, match.path)

    logger.debug("Exiting...")

if __name__ == '__main__':
    main()
